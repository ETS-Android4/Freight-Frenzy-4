import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.Gamepad;
import com.qualcomm.robotcore.util.Range;

import org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;
import org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;
import org.firstinspires.ftc.robotcore.external.navigation.AxesReference;
import org.firstinspires.ftc.robotcore.external.navigation.DistanceUnit;

@com.qualcomm.robotcore.eventloop.opmode.TeleOp(name="Simple Mechanum Tele-op", group="Teleop")

public class BasicMechanumTeleop extends LinearOpMode {

    BasicHardwareMap robot = new BasicHardwareMap();


    @Override
    public void runOpMode() {
        int stick_direction;
        double ly;
        double rx;
        double lx;
        double right_stick_x;
        double right_stick_y;

        double lift_rate;
        double rotation_rate;

        robot.teleopInit(hardwareMap);

        // Send telemetry message to signify robot waiting;
        telemetry.addData("Say", "Hello Driver");
        telemetry.update();

        // Wait for the game to start (driver presses PLAY)
        waitForStart();

        // run until the end of the match (driver presses STOP)
        while (opModeIsActive()) {

//            if (gamepad2.dpad_up){
//                robot.armMotor.setTargetPosition(robot.ARM_UP);
//                robot.armMotor.setPower(0.5);
//            }
//            else if (gamepad2.dpad_down){
//                robot.armMotor.setTargetPosition(robot.ARM_DOWN);
//                robot.armMotor.setPower(-0.5);
            //meow

//            telemetry.addData("armMotor Encodor",robot.armMotor.getCurrentPosition());
//            telemetry.update();
            right_stick_x = gamepad2.right_stick_x;
            if(Math.abs(right_stick_x) > robot.TELEOPDEADZONE) {
                rotation_rate = Math.abs(right_stick_x)*.00126+.000737; 
                if (right_stick_x > 0)
                    robot.armRotator.setPosition(robot.armRotator.getPosition()+rotation_rate);
                else
                    robot.armRotator.setPosition(robot.armRotator.getPosition()-rotation_rate);
            }

            telemetry.addData("rotator position", robot.armRotator.getPosition());
            telemetry.addData("lifter position", robot.armLifter.getPosition());
            telemetry.update();

            right_stick_y = gamepad2.right_stick_y;
            if(Math.abs(right_stick_y) > robot.TELEOPDEADZONE) {
                lift_rate = Math.abs(right_stick_y)*.001+.000737;
                if (right_stick_y > 0)
                    robot.armLifter.setPosition(robot.armLifter.getPosition()+lift_rate);
                else
                    robot.armLifter.setPosition(robot.armLifter.getPosition()-lift_rate);

            }

            if (gamepad2.right_trigger > 0.8) {
                robot.leftGrabber.setPosition(robot.LEFT_GRABBER_CLOSED);
                robot.rightGrabber.setPosition(robot.RIGHT_GRABBER_CLOSED);
            }

            if (gamepad2.right_bumper) {
                robot.leftGrabber.setPosition(robot.LEFT_GRABBER_OPEN);
                robot.rightGrabber.setPosition(robot.RIGHT_GRABBER_OPEN);
            }
            // Normal mode
            ly = -gamepad1.left_stick_y; //drive forward
            lx = -gamepad1.left_stick_x; //strafe
            rx = -gamepad1.right_stick_x; //turn

            if (Math.abs(ly) > robot.TELEOPDEADZONE ||
                    Math.abs(lx) > robot.TELEOPDEADZONE ||
                    Math.abs(rx) > robot.TELEOPDEADZONE) {

                // Compute the drive speed of each drive motor based on formula from redit
                double FL_power_raw = ly + lx - (rx * .7f);
                double FR_power_raw = ly - lx + (rx * .7f);
                double RL_power_raw = ly - lx - (rx * .7f);
                double RR_power_raw = ly + lx + (rx * .7f);

                //Clip the values generated by the above formula so that they never go outisde of -1 to 1
                double FL_power = Range.clip(FL_power_raw, -1, 1);
                double FR_power = Range.clip(FR_power_raw, -1, 1);
                double RL_power = Range.clip(RL_power_raw, -1, 1);
                double RR_power = Range.clip(RR_power_raw, -1, 1);

                robot.leftFrontDrive.setPower(FL_power);
                robot.rightFrontDrive.setPower(FR_power);
                robot.leftRearDrive.setPower(RL_power);
                robot.rightRearDrive.setPower(RR_power);

//                telemetry.addData("Encoder Value", robot.armMotor.getCurrentPosition());
//                telemetry.update();
            }
            else {
                robot.stop();
            }


           /* //arm control section todo add when hardware is there
            if (gamepad2.dpad_left){
                robot.leftGrabberServo.setPosition(robot.LEFT_GRABBER_OPEN);
                robot.rightGrabberServo.setPosition(robot.RIGHT_GRABBER_OPEN);
            }
            else if (gamepad2.dpad_right){
                robot.leftGrabberServo.setPosition(robot.LEFT_GRABBER_CLOSED);
                robot.rightGrabberServo.setPosition(robot.RIGHT_GRABBER_CLOSED);
            }*/


        }
    }
}